module FIFO_memory(clk,reset,din,read,write,dout,empty,full); 
 
	input clk; 
	input reset; 
	input [3:0]din;	//it data input 
	input read; 
	input write; 
 
	output [3:0]dout; //16-bit data output 
	output empty; 	   //flag to indicate that the memory is empty 
	output full;	   //flag to indicate that the memory is full 
	 
	parameter DEPTH=3, MAX_COUNT=3'b101;	 
//DEPTH is number of bits, 3 bits thus 2^3=8 memory locations and MAX_COUNT is the last memory location. 
	 
	reg [3:0]dout; 
	reg empty; 
	reg full; 
 
	/*head is write_pointer and tail is read_pointer*/ 
 
	reg [(DEPTH-1):0]tail;	 
// tail(3bits) defines memory pointer location for reading instructions(000 or 001....111) 
	 
	reg [(DEPTH-1):0]head;	 
// head(3bits) defines memory pointer location for writing instructions(000 or 001....111) 
	 
	reg [(DEPTH-1):0]count;	 
// 3 bits count register[000(0),001(1),010(2),....,111(7)] 
	 
	reg [3:0]fifo_mem[0:MAX_COUNT];  
// fifo memory is having 4 bits data and 5 memory locations 
	 
	reg sr_read_write_empty;			// 1 bit register flag 
 
///////// WHEN BOTH READING AND WRITING BUT FIFO IS EMPTY //////// 
 
	always @(posedge clk) 
		begin 
			if(reset==1) 
			//reset is pressed															 
				sr_read_write_empty <= 0; 
			else if(read==1 && empty==1 && write==1)	 
			//when fifo is empty and read & write both 1 
				sr_read_write_empty <= 1; 
			else 
				sr_read_write_empty <= 0; 
		end 
 
//////////////////////// COUNTER OPERATION /////////////////////// 
		 
	always @(posedge clk) 
		begin 
			if(reset==1) 
//when reset, the fifo is made empty thus count is set to zero 
				count <= 3'b000;		 
			else 
				begin 
					case({read,write}) 
					//CASE-1:when not reading or writing	 
						2'b00:	count <= count;				 
								//count remains same 
					//CASE-2:when writing only 
						2'b01:	if(count!=MAX_COUNT)			 
									count <= count+1; 
									//count increases 
					//CASE-3:when reading only							 
						2'b10:	if(count!=3'b000)				 
									count <= count-1;							 
									//count decreases 
					//CASE-4 
						2'b11:	if(sr_read_write_empty==1)	 
									count <= count+1; 
//(if) fifo is empty => only write, thus count increases			 
								else 
									count <= count; 
//(else) both read and write takes place, thus no change											 
					//DEFAULT CASE			 
						default: count <= count; 
					endcase 
				end 
		end 
 
////////////////////// EMPTY AND FULL ALERT ///////////////////// 
	 
	// Memory empty signal 
	always @(count) 
		begin 
			if(count==3'b000) 
				empty <= 1; 
			else 
				empty <= 0; 
		end 
 
	// Memory full signal 
	always @(count) 
		begin 
			if(count==MAX_COUNT) 
				full <= 1; 
			else 
				full <= 0; 
		end 
 
///////////// READ AND WRITE POINTER MEMORY LOCATION ///////////// 
 
	// Write operation memory pointer 
	always @(posedge clk) 
		begin 
			if(reset==1) 
			//head moved to zero location (fifo is made empty) 
				head <= 3'b000;	 
			else 
				begin 
					if(write==1 && full==0)	 
					//writing when memory is NOT FULL 
						head <= head+1; 
				end 
		end 
	 
	// Read operation memory pointer 
		always @(posedge clk) 
			begin 
				if(reset==1) 
				//tail moved to zero location (fifo is made empty) 
					tail <= 3'b000;	 
				else 
					begin 
						if(read==1 && empty==0)	 
						//reading when memory is NOT ZERO 
							tail <= tail+1; 
					end 
			end 
 
//////////////////// READ AND WRITE OPERATION //////////////////// 
 
	// Write operation 
	always @(posedge clk) 
		//IT CAN WRITE WHEN RESET IS USED AS FULL==0	 
		begin 
			if(write==1 && full==0) 
			//writing when memory is NOT FULL 
				fifo_mem[head] <= din; 
			else									 
			//when NOT WRITING 
				fifo_mem[head] <= fifo_mem[head]; 
		end 
 
	// Read operation 
	always @(posedge clk) 
		begin 
			if(reset==1)						 
			//reset implies output is zero 
				dout <= 3'b000; 
			else if(read==1 && empty==0)	 
			//reading data when memory is NOT EMPTY 
				dout <= fifo_mem[tail]; 
			else 
			//no change 
				dout <= dout;  
		end 
endmodule 

**************************************************************************************************

// FIFO -> First in First out
// main point to remmeber while designin a FIFO is
// don't write to full buffer and don't read from empty buffer
// is it okay?yeahh understood

`timescale 1ns / 1ps

module my_fifo(
input clk,
input reset,
input read_en,
input write_en,
input [3:0] data_in,
output reg [3:0] data_out,
output full,
output empty
    );
    
//now that we have all the ports we need, we will declare memory

reg [3:0] mem [0:4];

// we need two  pointers to point read and write locations

reg [2:0]read_pointer,write_pointer; // since depth is 5. we need pointer to be log(5) base 2 got it

//  now main logic
/* it's simple.. non blocking is represented with <= symbol
blocking is only = symbol
the difference is.. when i use non-blocking all the statements run parallaly
if i use blocking they run sequentially*/

always @(posedge clk)
begin
if(reset)
begin
    read_pointer <= 0;
    write_pointer <=  0;
end
else
begin
// now we want to see if user is reading or writing
case({read_en,write_en})

2'b00 : begin end // here both read and write are zero.. so we do nothing

2'b01 : begin  // write
              if(!full)
              begin
              mem[write_pointer] <= data_in;
              write_pointer <= write_pointer + 1;
              end
            end
            
2'b10 : begin // read
            if(!empty)
            begin
                data_out <= mem[read_pointer];
                read_pointer <= read_pointer + 1;
            end
        end
        
2'b11 : begin
            data_out <= mem[read_pointer];
            read_pointer <= read_pointer + 1;
            mem[write_pointer] <= data_in;
            write_pointer <= write_pointer + 1;
        end
endcase
end
end
// sorry my bad.. we kept these inside always block
assign empty = (read_pointer == write_pointer) ? 1'b1 :1'b0; // so buffer can be empty.. when you have no element to read.. doesn't need to be 0 position only..

// suppose you write 3  numbers.. write pointer becomes 3.. if you read all 3.. then it's empty na.. so read_pointer == write_pointer is empty condiotn

// any doubts? no i understood it very well :(
assign full = (write_pointer == 3'd4) ? 1'b1 : 1'b0;

endmodule

// perfect.. we are wriitng 3 numbers and reading one number yeahhhhhhh